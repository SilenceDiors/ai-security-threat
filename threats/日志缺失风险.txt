# 日志缺失风险
**威胁类别**：智能体层 - 日志记录缺失风险  
**风险等级**：P2（中危）
## 1. 漏洞原理
### 1.1 缺少审计日志
如果没有日志记录，将造成数据的否认风险，关于对智能体的自主操作和问询记录抗抵赖。
### 1.2 影响范围
- 用户查询记录缺失
- 工具执行操作无日志
- 提示词变更未记录
- 训练数据更新无追踪
## 2. 漏洞危害
- **抗抵赖风险**：无法证明操作是谁执行的
- **安全事件无法溯源**：发生安全事件无法追查
- **合规风险**：不符合审计要求
- **责任划分困难**：无法明确操作责任
- **异常行为无法发现**：缺少监控数据
## 3. 修复方式
### 3.1 开发原则
- 记录用户查询/工具调用/提示词变更等关键操作
- 日志脱敏
- 日志写保护
- 日志保留策略
### 3.2 修复建议
#### 3.2.1 关键操作日志
对于封装的智能体服务层必须要有用户查询、执行操作等日志记录：
```python
import logging
from datetime import datetime
import json
class AuditLogger:
    def __init__(self):
        self.logger = logging.getLogger('audit')
        self.logger.setLevel(logging.INFO)
        
        # 配置日志处理器
        handler = logging.FileHandler('audit.log')
        handler.setFormatter(logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        ))
        self.logger.addHandler(handler)
    
    def log_user_query(self, user_id, query, response, model_used):
        """记录用户查询"""
        log_entry = {
            'event_type': 'user_query',
            'timestamp': datetime.now().isoformat(),
            'user_id': user_id,
            'query': self.sanitize_sensitive_data(query),
            'response': self.sanitize_sensitive_data(response),
            'model': model_used,
            'ip_address': request.remote_addr,
        }
        self.logger.info(json.dumps(log_entry))
    
    def log_tool_execution(self, user_id, tool_name, parameters, result):
        """记录工具执行"""
        log_entry = {
            'event_type': 'tool_execution',
            'timestamp': datetime.now().isoformat(),
            'user_id': user_id,
            'tool_name': tool_name,
            'parameters': self.sanitize_sensitive_data(parameters),
            'result': result,
        }
        self.logger.info(json.dumps(log_entry))
    
    def log_prompt_change(self, admin_id, old_prompt, new_prompt, reason):
        """记录提示词变更"""
        log_entry = {
            'event_type': 'prompt_change',
            'timestamp': datetime.now().isoformat(),
            'admin_id': admin_id,
            'old_prompt_hash': self.hash_text(old_prompt),
            'new_prompt_hash': self.hash_text(new_prompt),
            'reason': reason,
        }
        self.logger.info(json.dumps(log_entry))
    
    def log_training_data_update(self, admin_id, data_source, operation, affected_records):
        """记录训练数据更新"""
        log_entry = {
            'event_type': 'training_data_update',
            'timestamp': datetime.now().isoformat(),
            'admin_id': admin_id,
            'data_source': data_source,
            'operation': operation,  # add/update/delete
            'affected_records': affected_records,
        }
        self.logger.info(json.dumps(log_entry))
    
    def sanitize_sensitive_data(self, data):
        """日志脱敏"""
        if isinstance(data, str):
            # 脱敏邮箱
            data = re.sub(r'([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', 
                         r'\1***@\2', data)
            # 脱敏手机号
            data = re.sub(r'\b(\d{3})\d{4}(\d{4})\b', r'\1****\2', data)
            # 脱敏身份证
            data = re.sub(r'\b(\d{4})\d{10}(\d{4})\b', r'\1**********\2', data)
        return data
    
    def hash_text(self, text):
        """对文本进行哈希"""
        import hashlib
        return hashlib.sha256(text.encode()).hexdigest()[:16]
```
#### 3.2.2 使用示例
```python
audit_logger = AuditLogger()
@app.route('/api/agent/query', methods=['POST'])
@token_required
def agent_query(current_user):
    """用户查询"""
    query = request.json.get('query')
    
    # 调用模型
    response = model.generate(query)
    
    # 记录日志
    audit_logger.log_user_query(
        user_id=current_user.id,
        query=query,
        response=response,
        model_used='gpt-4'
    )
    
    return jsonify({'response': response})
@app.route('/api/tools/execute', methods=['POST'])
@token_required
def execute_tool(current_user):
    """执行工具"""
    tool_name = request.json.get('tool')
    params = request.json.get('params')
    
    # 执行工具
    result = run_tool(tool_name, params)
    
    # 记录日志
    audit_logger.log_tool_execution(
        user_id=current_user.id,
        tool_name=tool_name,
        parameters=params,
        result=result['status']
    )
    
    return jsonify(result)
```
#### 3.2.3 日志保护
日志写保护，防止篡改：
```python
import os
import stat
def protect_log_file(log_path):
    """保护日志文件"""
    # 设置只能追加，不能修改或删除
    os.chmod(log_path, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP)
    
    # 或使用chattr（Linux）
    # os.system(f'chattr +a {log_path}')
```
#### 3.2.4 日志保留策略
```python
from datetime import datetime, timedelta
import glob
class LogRetentionPolicy:
    def __init__(self, log_dir, retention_days=90):
        self.log_dir = log_dir
        self.retention_days = retention_days
    
    def cleanup_old_logs(self):
        """清理过期日志"""
        cutoff_date = datetime.now() - timedelta(days=self.retention_days)
        
        for log_file in glob.glob(f"{self.log_dir}/*.log"):
            file_mtime = datetime.fromtimestamp(os.path.getmtime(log_file))
            
            if file_mtime < cutoff_date:
                # 归档到冷存储
                self.archive_log(log_file)
                
                # 删除本地文件
                os.remove(log_file)
    
    def archive_log(self, log_file):
        """归档日志到冷存储"""
        # 上传到S3/OSS等对象存储
        pass
```
#### 3.2.5 日志查询和分析
```python
class LogAnalyzer:
    def query_user_activity(self, user_id, start_date, end_date):
        """查询用户活动"""
        logs = []
        
        with open('audit.log', 'r') as f:
            for line in f:
                try:
                    log_entry = json.loads(line.split(' - ')[-1])
                    
                    if log_entry.get('user_id') == user_id:
                        log_time = datetime.fromisoformat(log_entry['timestamp'])
                        
                        if start_date <= log_time <= end_date:
                            logs.append(log_entry)
                except:
                    continue
        
        return logs
    
    def detect_anomalies(self, user_id):
        """检测异常行为"""
        logs = self.query_user_activity(user_id, 
                                        datetime.now() - timedelta(days=7),
                                        datetime.now())
        
        # 分析异常模式
        anomalies = []
        
        # 1. 高频查询
        query_count = len([l for l in logs if l['event_type'] == 'user_query'])
        if query_count > 1000:  # 一周超过1000次
            anomalies.append({'type': 'high_frequency', 'count': query_count})
        
        # 2. 异常时间段活动
        night_activities = [l for l in logs 
                           if 0 <= datetime.fromisoformat(l['timestamp']).hour < 6]
        if len(night_activities) > 100:
            anomalies.append({'type': 'unusual_time', 'count': len(night_activities)})
        
        return anomalies
```
## 4. 触发场景
- 日志记录功能
## 5. 日志记录要求
### 5.1 必须记录的事件
- [ ] 用户登录/登出
- [ ] 用户查询和AI响应
- [ ] 工具调用和执行结果
- [ ] 提示词创建/修改/删除
- [ ] 训练数据更新
- [ ] 权限变更
- [ ] 配置修改
- [ ] 错误和异常
### 5.2 日志内容要求
- 时间戳
- 用户ID
- 操作类型
- 操作对象
- 操作结果
- IP地址
- User-Agent
### 5.3 日志安全要求
- 敏感数据脱敏
- 日志加密存储
- 访问控制
- 完整性保护
- 定期备份
## 6. 检查清单
- [ ] 是否记录用户查询日志
- [ ] 是否记录工具执行日志
- [ ] 是否记录提示词变更日志
- [ ] 是否记录训练数据更新日志
- [ ] 日志是否包含必要信息
- [ ] 敏感数据是否脱敏
- [ ] 日志文件是否有写保护
- [ ] 是否有日志保留策略
- [ ] 是否定期审查日志
## 7. 合规要求
- **等保2.0**：要求记录安全审计日志
- **GDPR**：要求记录个人数据处理活动
- **ISO 27001**：要求日志记录和监控
- **行业规范**：金融、医疗等行业的日志要求
