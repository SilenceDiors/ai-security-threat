# 命令/代码执行
**威胁类别**：智能体层 - RCE  
**风险等级**：P0（严重）
## 1. 漏洞原理
### 1.1 远程代码执行（RCE）
封装层服务被平台交互输入造成RCE问题，攻击者可以直接控制封装层服务器。
### 1.2 攻击途径
- **用户输入注入**：用户输入未经过滤直接执行
- **模型输出执行**：直接执行模型生成的代码
- **反序列化漏洞**：不安全的对象反序列化
- **模板注入**：SSTI（服务端模板注入）
- **命令注入**：通过参数注入系统命令
### 1.3 危险函数
```python
# Python危险函数
eval()
exec()
os.system()
subprocess.call()
compile()
__import__()
# JavaScript危险函数
eval()
Function()
setTimeout()/setInterval() with string
require() with user input
# PHP危险函数
eval()
assert()
system()
exec()
shell_exec()
```
## 2. 漏洞危害
- **完全控制服务器**：获取系统最高权限
- **数据泄露**：窃取数据库和文件系统数据
- **横向移动**：攻击内网其他系统
- **植入后门**：持久化控制
- **挖矿/勒索**：利用服务器资源挖矿或勒索
- **业务中断**：破坏系统导致服务不可用
## 3. 修复方式
### 3.1 开发原则
- **禁用危险函数**：完全禁止使用exec/eval等
- **输入验证**：严格验证和净化所有输入
- **最小权限**：使用最低权限运行服务
- **隔离执行**：使用容器或沙箱隔离
- **使用安全SDK**：使用公司提供的安全SDK
### 3.2 修复建议
#### 3.2.1 禁用危险函数
禁用exec/eval/shell等危险函数：
```python
# 危险做法：直接执行用户输入
def process_input(user_code):
    eval(user_code)  # 禁止！
    exec(user_code)  # 禁止！
# 安全做法：不执行用户代码
def process_input(user_input):
    # 使用安全的解析和验证
    validated_data = json.loads(user_input)
    return process_validated_data(validated_data)
```
#### 3.2.2 命令执行白名单
如需命令执行，使用固定命令白名单+参数校验：
```python
# 危险做法
def run_command(cmd):
    os.system(cmd)  # 可注入！
# 安全做法
ALLOWED_COMMANDS = {
    "list": ["ls", "-la"],
    "status": ["systemctl", "status"],
}
def run_safe_command(action, params=None):
    if action not in ALLOWED_COMMANDS:
        raise ValueError("Command not allowed")
    
    # 使用列表形式，防止注入
    cmd = ALLOWED_COMMANDS[action].copy()
    
    # 严格验证参数
    if params:
        validated_params = validate_params(params)
        cmd.extend(validated_params)
    
    # 使用subprocess安全执行
    result = subprocess.run(
        cmd,
        capture_output=True,
        timeout=10,
        check=True
    )
    return result.stdout
```
#### 3.2.3 执行器隔离
使用Docker/AWS Lambda等隔离环境：
```python
# 使用Docker隔离执行
import docker
def execute_in_container(code):
    client = docker.from_env()
    
    # 创建隔离容器
    container = client.containers.run(
        "python:3.9-slim",
        command=f"python -c '{code}'",
        detach=True,
        mem_limit="128m",
        cpu_quota=50000,
        network_disabled=True,  # 禁用网络
        read_only=True,         # 只读文件系统
        remove=True,
        timeout=5
    )
    
    # 获取输出
    output = container.logs()
    return output
```
#### 3.2.4 安全序列化/反序列化
使用公司提供的安全序列化SDK：
```python
# 危险做法：pickle反序列化
import pickle
data = pickle.loads(user_input)  # 可执行任意代码！
# 安全做法：使用JSON
import json
data = json.loads(user_input)  # 只解析数据
# 安全做法：使用公司安全SDK
from company_security_sdk import safe_deserialize
data = safe_deserialize(user_input, schema=UserInputSchema)
```
#### 3.2.5 模板引擎安全配置
```python
# 危险做法：允许执行代码的模板
from jinja2 import Template
template = Template(user_input)
result = template.render()  # SSTI风险！
# 安全做法：使用沙箱环境
from jinja2.sandbox import SandboxedEnvironment
env = SandboxedEnvironment()
template = env.from_string(user_input)
result = template.render()
```
#### 3.2.6 输入验证和净化
```python
def validate_input(user_input):
    """严格验证用户输入"""
    # 1. 类型检查
    if not isinstance(user_input, str):
        raise TypeError("Invalid input type")
    
    # 2. 长度限制
    if len(user_input) > 1000:
        raise ValueError("Input too long")
    
    # 3. 危险字符检测
    dangerous_chars = [';', '&', '|', '$', '`', '\n', '\r']
    if any(char in user_input for char in dangerous_chars):
        raise ValueError("Dangerous characters detected")
    
    # 4. 危险关键词检测
    dangerous_keywords = ['eval', 'exec', 'import', '__', 'system']
    if any(kw in user_input.lower() for kw in dangerous_keywords):
        raise ValueError("Dangerous keywords detected")
    
    return user_input
```
## 4. 触发场景
- 命令执行场景
- 序列化/反序列化
- 三方组件引入
## 5. 检测方法
### 5.1 代码审计
- 搜索危险函数：`eval`, `exec`, `system`, `shell_exec`
- 检查用户输入处理流程
- 审查反序列化代码
- 检查模板引擎使用
### 5.2 安全测试
```bash
# 命令注入测试
input: "; cat /etc/passwd"
input: "| whoami"
input: "& id"
# 代码执行测试
input: "__import__('os').system('ls')"
input: "eval('1+1')"
# 反序列化测试
input: "pickle payload with malicious code"
```
## 6. 防护清单
- [ ] 是否完全禁用eval/exec等危险函数
- [ ] 命令执行是否使用白名单
- [ ] 是否使用参数化命令（列表形式）
- [ ] 是否实现输入验证和净化
- [ ] 是否使用隔离环境（Docker/Lambda）
- [ ] 是否使用安全的序列化方式
- [ ] 是否限制执行超时和资源
- [ ] 是否使用公司安全SDK
- [ ] 是否定期安全审计和渗透测试
## 7. 应急响应
发现RCE漏洞时的应急措施：
1. **立即下线**：停止受影响服务
2. **隔离系统**：防止横向移动
3. **排查日志**：确定攻击范围
4. **修复漏洞**：紧急修复并测试
5. **安全加固**：全面安全检查
6. **上线验证**：确认修复有效
7. **事后总结**：复盘并改进流程
