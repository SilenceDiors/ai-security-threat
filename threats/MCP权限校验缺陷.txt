# MCP权限校验缺陷

**威胁类别**：智能体层 - 失效的权限控制  
**风险等级**：P0（严重）

## 1. 漏洞原理

### 1.1 权限控制缺失
权限控制缺失，越权执行MCP服务工具，可能导致未授权访问和恶意操作。

### 1.2 常见问题
- **无鉴权机制**：MCP服务未实施任何身份验证
- **自实现鉴权缺陷**：自行实现的令牌验证存在漏洞
- **OAuth配置不安全**：OAuth配置错误或使用不安全的模式
- **令牌验证不完整**：未验证令牌有效性、过期时间等

## 2. 漏洞危害

- **未授权访问**：任何人都可以调用MCP工具
- **数据泄露**：越权访问他人数据
- **恶意操作**：执行危险的工具调用
- **权限提升**：低权限用户获取高权限功能
- **业务风险**：造成业务数据被篡改或删除

## 3. 修复方式

### 3.1 开发原则
- **不要自行实现令牌验证或授权逻辑**
- **务必验证令牌**
- 使用标准OAuth 2.0流程
- 遵循MCP安全最佳实践

### 3.2 修复建议

**参考官方文档**：
https://modelcontextprotocol.io/docs/tutorials/security/authorization

#### 3.2.1 使用标准OAuth 2.0
```typescript
// MCP服务端配置
import { MCPServer } from "@modelcontextprotocol/sdk/server/index.js";
import { OAuthProvider } from "@modelcontextprotocol/sdk/auth/oauth.js";

const server = new MCPServer({
  name: "secure-mcp-server",
  version: "1.0.0",
});

// 配置OAuth提供商
const oauthProvider = new OAuthProvider({
  clientId: process.env.OAUTH_CLIENT_ID,
  clientSecret: process.env.OAUTH_CLIENT_SECRET,
  authorizationURL: "https://oauth.example.com/authorize",
  tokenURL: "https://oauth.example.com/token",
  scope: ["mcp.tools.read", "mcp.tools.write"],
});

// 验证令牌中间件
server.use(async (context, next) => {
  const token = context.request.headers.authorization?.split(" ")[1];
  
  if (!token) {
    throw new Error("Missing authorization token");
  }
  
  // 验证令牌
  const userInfo = await oauthProvider.verifyToken(token);
  if (!userInfo) {
    throw new Error("Invalid token");
  }
  
  // 将用户信息添加到上下文
  context.user = userInfo;
  await next();
});
```

#### 3.2.2 工具权限控制
```typescript
// 定义工具权限
const toolPermissions = {
  "read_file": ["mcp.tools.read"],
  "write_file": ["mcp.tools.write"],
  "delete_file": ["mcp.tools.admin"],
  "execute_command": ["mcp.tools.admin"],
};

// 工具注册时添加权限检查
server.tool("write_file", 
  {
    description: "Write content to a file",
    parameters: {
      path: { type: "string" },
      content: { type: "string" },
    },
  },
  async (params, context) => {
    // 检查用户权限
    const requiredScopes = toolPermissions["write_file"];
    const userScopes = context.user.scopes || [];
    
    const hasPermission = requiredScopes.every(scope => 
      userScopes.includes(scope)
    );
    
    if (!hasPermission) {
      throw new Error("Insufficient permissions");
    }
    
    // 执行工具操作
    await writeFile(params.path, params.content);
    return { success: true };
  }
);
```

#### 3.2.3 令牌验证最佳实践
```typescript
class TokenValidator {
  async validateToken(token: string) {
    // 1. 验证令牌格式
    if (!token || typeof token !== 'string') {
      throw new Error("Invalid token format");
    }
    
    // 2. 验证令牌签名（使用OAuth提供商的公钥）
    const publicKey = await this.getOAuthPublicKey();
    const isValid = await this.verifySignature(token, publicKey);
    if (!isValid) {
      throw new Error("Invalid token signature");
    }
    
    // 3. 验证令牌过期时间
    const payload = this.decodeToken(token);
    if (payload.exp && payload.exp < Date.now() / 1000) {
      throw new Error("Token expired");
    }
    
    // 4. 验证令牌发行者
    if (payload.iss !== this.expectedIssuer) {
      throw new Error("Invalid token issuer");
    }
    
    // 5. 验证受众
    if (!payload.aud.includes(this.expectedAudience)) {
      throw new Error("Invalid token audience");
    }
    
    return payload;
  }
}
```

#### 3.2.4 安全配置示例
```json
{
  "mcpServers": {
    "secure-server": {
      "command": "node",
      "args": ["server.js"],
      "auth": {
        "type": "oauth2",
        "provider": "your-oauth-provider",
        "clientId": "${OAUTH_CLIENT_ID}",
        "clientSecret": "${OAUTH_CLIENT_SECRET}",
        "scopes": ["mcp.tools.read", "mcp.tools.write"],
        "tokenValidation": {
          "verifySignature": true,
          "checkExpiration": true,
          "enforceScopes": true
        }
      },
      "tools": {
        "read_file": {
          "requiredScopes": ["mcp.tools.read"]
        },
        "write_file": {
          "requiredScopes": ["mcp.tools.write"]
        },
        "delete_file": {
          "requiredScopes": ["mcp.tools.admin"]
        }
      }
    }
  }
}
```

## 4. 触发场景

- AI处理场景/工具新增

## 5. 测试用例

### 5.1 无令牌测试
```bash
# 应该返回401 Unauthorized
curl -X POST http://mcp-server/tool/read_file \
  -H "Content-Type: application/json" \
  -d '{"path": "/etc/passwd"}'
```

### 5.2 无效令牌测试
```bash
# 应该返回403 Forbidden
curl -X POST http://mcp-server/tool/read_file \
  -H "Authorization: Bearer invalid_token" \
  -H "Content-Type: application/json" \
  -d '{"path": "/etc/passwd"}'
```

### 5.3 权限不足测试
```bash
# 使用只读令牌调用写入工具
# 应该返回403 Forbidden
curl -X POST http://mcp-server/tool/write_file \
  -H "Authorization: Bearer ${READ_ONLY_TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{"path": "/tmp/test", "content": "data"}'
```

## 6. 检查清单

- [ ] 是否使用标准OAuth 2.0
- [ ] 是否验证令牌签名
- [ ] 是否检查令牌过期时间
- [ ] 是否验证令牌发行者和受众
- [ ] 是否实施工具级权限控制
- [ ] 是否使用环境变量存储密钥
- [ ] 是否记录权限验证失败日志
- [ ] 是否定期轮换密钥

## 7. 常见错误

### 7.1 错误示例：自实现令牌验证
```typescript
// 错误：自行实现验证逻辑
function validateToken(token) {
  return token === "my_secret_token";  // 不安全！
}
```

### 7.2 错误示例：不验证令牌
```typescript
// 错误：直接信任令牌
server.tool("dangerous_operation", async (params, context) => {
  // 没有验证context.token！
  await performDangerousOperation();
});
```

### 7.3 正确做法
```typescript
// 正确：使用OAuth提供商验证
server.use(async (context, next) => {
  const token = context.request.headers.authorization?.split(" ")[1];
  context.user = await oauthProvider.verifyToken(token);
  await next();
});
```

## 8. 参考资源

- [MCP Security: Authorization](https://modelcontextprotocol.io/docs/tutorials/security/authorization)
- [OAuth 2.0 RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)
- [JWT Best Practices](https://datatracker.ietf.org/doc/html/rfc8725)
