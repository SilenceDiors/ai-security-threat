# 模型的并发控制缺失

**威胁类别**：模型层 - 模型拒绝服务  
**风险等级**：P2（中危）

## 1. 漏洞原理

### 1.1 并发攻击
攻击者同时发送大量请求，导致系统资源耗尽，造成拒绝服务。

### 1.2 缺乏限流机制
- 未设置单IP请求频率限制
- 未实施分布式限流
- 缺少请求队列化处理
- 无熔断降级机制

### 1.3 资源耗尽路径
- 大量并发请求占满连接池
- 模型推理资源被耗尽
- 内存和CPU资源不足
- 数据库连接池耗尽

## 2. 漏洞危害

- **服务不可用**：正常用户无法使用服务
- **资源耗尽**：服务器资源被恶意占用
- **成本增加**：云服务费用激增
- **业务中断**：关键业务流程受影响
- **连锁反应**：影响其他依赖服务

## 3. 修复方式

### 3.1 开发原则
- 实施多层次限流策略
- 建立请求队列化机制
- 实现熔断降级保护
- 监控和告警系统

### 3.2 修复建议

#### 3.2.1 API网关限流
在API网关配置限流规则：
```nginx
# Nginx配置示例
limit_req_zone $binary_remote_addr zone=api_limit:10m rate=50r/m;

location /api/ {
    limit_req zone=api_limit burst=10 nodelay;
    proxy_pass http://backend;
}
```

#### 3.2.2 分布式限流
使用Redis实现分布式限流：
```python
import redis
import time

def rate_limit(user_id, max_requests=50, window=60):
    """
    限流：每个用户每分钟最多50次请求
    """
    r = redis.Redis()
    key = f"rate_limit:{user_id}"
    
    current = r.incr(key)
    if current == 1:
        r.expire(key, window)
    
    if current > max_requests:
        return False  # 超出限制
    return True  # 允许请求
```

#### 3.2.3 请求队列化
实现请求队列避免瞬时压力：
```python
from celery import Celery

app = Celery('tasks', broker='redis://localhost:6379/0')

@app.task(rate_limit='100/m')
def process_model_request(prompt):
    """异步处理模型请求"""
    result = model.generate(prompt)
    return result
```

#### 3.2.4 熔断降级机制
```python
from circuitbreaker import circuit

@circuit(failure_threshold=5, recovery_timeout=60)
def call_model_service(prompt):
    """
    熔断器：5次失败后熔断，60秒后恢复
    """
    response = model_service.predict(prompt)
    return response
```

#### 3.2.5 监控和告警
- 实时监控请求QPS
- 监控资源使用率（CPU、内存、GPU）
- 设置阈值告警
- 自动扩容机制

## 4. 触发场景

- 高并发场景
- Token使用上限
- 模型迁移

## 5. 配置建议

### 5.1 限流配置
- **单IP限制**：50次/分钟
- **用户限制**：100次/分钟
- **全局限制**：10000次/分钟
- **突发流量**：允许burst 10

### 5.2 熔断配置
- **失败阈值**：5次连续失败
- **熔断时间**：60秒
- **降级策略**：返回缓存结果或友好提示

### 5.3 队列配置
- **队列长度**：1000
- **超时时间**：30秒
- **工作进程**：根据CPU核心数调整

## 6. 监控指标

- **请求QPS**：每秒请求数
- **响应时间**：P50、P95、P99
- **错误率**：4xx、5xx错误占比
- **并发连接数**：当前活跃连接
- **资源使用率**：CPU、内存、GPU使用率
